name: üöÄ UNIFIED DEPLOY ALL (Google, Huawei, iOS)

on:
  workflow_dispatch:
    inputs:
      bump_version:
        description: 'Auto-bump version in pubspec.yaml?'
        required: true
        default: 'true'
        type: boolean
      release_notes:
        description: 'Release notes (What is new)'
        required: false
        default: 'Automatsko a≈æuriranje (Performance Fixes)'
      submit_for_review_huawei:
        description: 'Huawei: Submit for review?'
        required: false
        default: 'true'
        type: boolean
      force_replace_review_huawei:
        description: 'Huawei: Force replace review?'
        required: false
        default: 'false'
        type: boolean
      submit_for_review_ios:
        description: 'iOS: Submit for review?'
        required: false
        default: 'true'
        type: boolean
      dry_run:
        description: 'Dry Run? (Build ONLY - No Upload)'
        required: true
        default: 'false'
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  FLUTTER_VERSION: '3.35.6'

permissions:
  contents: write

jobs:
  # ==============================================================================
  # 1. BUMP VERSION JOB (Runs first, updates repo)
  # ==============================================================================
  bump-and-tag:
    name: üîñ Bump Version
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump_step.outputs.NEW_VERSION || steps.read_step.outputs.NEW_VERSION }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Auto-Bump Version
        id: bump_step
        if: ${{ inputs.bump_version == true }}
        shell: bash
        run: |
          # Read version from pubspec.yaml
          LINE=$(grep "^version: " pubspec.yaml)
          VERSION_PART=$(echo "$LINE" | sed 's/version: //g' | cut -d+ -f1)
          BUILD_PART=$(echo "$LINE" | sed 's/.*+//g')

          # Split version into major.minor.patch
          IFS='.' read -r -a parts <<< "$VERSION_PART"
          MAJOR="${parts[0]}"
          MINOR="${parts[1]}"
          PATCH="${parts[2]}"

          # Increment Patch and Build (Patch + 1, Build + 1)
          NEW_PATCH=$((PATCH + 1))
          NEW_BUILD=$((BUILD_PART + 1))

          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH+$NEW_BUILD"
          echo "[INFO] Bumping version: $VERSION_PART+$BUILD_PART -> $NEW_VERSION"

          # Update file using sed (inplace)
          sed -i "s/^version: .*/version: $NEW_VERSION/" pubspec.yaml

          # Output for other jobs
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT

          # Git commit and push
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"
          git add pubspec.yaml
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Auto-bump version to $NEW_VERSION [skip ci]"
            git push origin HEAD:${{ github.ref_name }}
            echo "‚úÖ Version bumped and pushed."
          fi
      
      - name: Read Version (if not bumped)
        id: read_step
        if: ${{ inputs.bump_version == false }}
        run: |
           LINE=$(grep "^version: " pubspec.yaml)
           VERSION_PART=$(echo "$LINE" | sed 's/version: //g')
           echo "NEW_VERSION=$VERSION_PART" >> $GITHUB_OUTPUT

  # ==============================================================================
  # 2. GOOGLE PLAY (Alpha)
  # ==============================================================================
  deploy-google:
    name: ü§ñ Google Play (Alpha)
    needs: bump-and-tag
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }} # Checkout the branch (including new push)

      - name: Pull Latest Changes (Ensure we have the bump)
        run: git pull origin ${{ github.ref_name }}

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'zulu'
          java-version: '17'
          cache: 'gradle'

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: 'stable'
          cache: true

      - name: Prepare secrets (Linux)
        run: |
          # 1. Restore Keystore
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 -d > android/gavra-release-key-production.keystore
          
          # 2. Create key.properties
          echo "storePassword=${{ secrets.KEYSTORE_PASSWORD }}" > android/key.properties
          echo "keyPassword=${{ secrets.KEY_PASSWORD }}" >> android/key.properties
          echo "keyAlias=${{ secrets.KEY_ALIAS }}" >> android/key.properties
          echo "storeFile=../gavra-release-key-production.keystore" >> android/key.properties

          # 3. Restore Google Play JSON
          echo "${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}" > android/google-service-account.json

          # 4. Restore AgConnect (Huawei) - Required for build even if not releasing to Huawei
          mkdir -p android/app
          echo "${{ secrets.AGC_BASE64 }}" | base64 -d > android/app/agconnect-services.json

      - name: Get dependencies
        run: flutter pub get

      - name: Build AAB
        run: |
          VERSION_NAME=$(echo "${{ needs.bump-and-tag.outputs.new_version }}" | cut -d+ -f1)
          VERSION_CODE=$(echo "${{ needs.bump-and-tag.outputs.new_version }}" | cut -d+ -f2)
          flutter build appbundle --release --build-name=$VERSION_NAME --build-number=$VERSION_CODE

      - name: Upload to Google Play (Closed Testing)
        if: ${{ inputs.dry_run == false }}
        uses: r0adkll/upload-google-play@v1
        with:
          serviceAccountJsonPlainText: ${{ secrets.GOOGLE_PLAY_SERVICE_ACCOUNT_JSON }}
          packageName: com.gavra013.gavra_android
          releaseFiles: build/app/outputs/bundle/release/app-release.aab
          track: alpha
          status: completed
          releaseName: "v${{ needs.bump-and-tag.outputs.new_version }}"

  # ==============================================================================
  # 3. HUAWEI APPGALLERY
  # ==============================================================================
  deploy-huawei:
    name: üì± Huawei AppGallery
    needs: bump-and-tag
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}

      - name: Pull Latest Changes
        run: git pull origin ${{ github.ref_name }}

      - name: Setup Java
        uses: actions/setup-java@v3
        with:
          distribution: 'zulu'
          java-version: '17'
          cache: 'gradle'

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: 'stable'
          cache: true

      - name: Prepare Secrets (Linux)
        env:
          AGC_BASE64: ${{ secrets.AGC_BASE64 }}
          KEYSTORE_BASE64: ${{ secrets.KEYSTORE_BASE64 }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
          STORE_PASSWORD: ${{ secrets.STORE_PASSWORD }}
        run: |
          mkdir -p android/app
          mkdir -p assets
          echo "${{ secrets.AGC_BASE64 }}" | base64 -d > android/app/agconnect-services.json
          cp android/app/agconnect-services.json assets/agconnect-services.json

          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 -d > android/app/upload-keystore.jks

          echo "storePassword=${{ secrets.STORE_PASSWORD }}" > android/key.properties
          echo "keyPassword=${{ secrets.KEY_PASSWORD }}" >> android/key.properties
          echo "keyAlias=${{ secrets.KEY_ALIAS }}" >> android/key.properties
          echo "storeFile=upload-keystore.jks" >> android/key.properties

      - name: Get dependencies
        run: flutter pub get

      - name: Build Release APK
        run: flutter build apk --release

      - name: Upload to Huawei AppGallery (Bash)
        if: ${{ inputs.dry_run == false }}
        env:
          HUAWEI_CLIENT_ID: ${{ secrets.AGC_CLIENT_ID }}
          HUAWEI_CLIENT_SECRET: ${{ secrets.AGC_CLIENT_SECRET }}
          HUAWEI_APP_ID: ${{ secrets.AGC_APP_ID }}
          SUBMIT: ${{ inputs.submit_for_review_huawei }}
          FORCE_REPLACE: ${{ inputs.force_replace_review_huawei }}
        shell: bash
        run: |
          echo "[INFO] Uploading to Huawei..."
          # (Simplified logic from verified workflow)
          TOKEN_RESPONSE=$(curl -s -X POST "https://connect-api.cloud.huawei.com/api/oauth2/v1/token" -H "Content-Type: application/json" -d "{\"client_id\": \"$HUAWEI_CLIENT_ID\", \"client_secret\": \"$HUAWEI_CLIENT_SECRET\", \"grant_type\": \"client_credentials\"}")
          ACCESS_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.access_token')
          
          if [ "$FORCE_REPLACE" == "true" ]; then
             curl -s -X PUT "https://connect-api.cloud.huawei.com/api/publish/v2/app-cancel-submit?appId=$HUAWEI_APP_ID" -H "Authorization: Bearer $ACCESS_TOKEN" -H "client_id: $HUAWEI_CLIENT_ID" -H "Content-Type: application/json"
             sleep 5
          fi

          UPLOAD_URL_RESPONSE=$(curl -s -X GET "https://connect-api.cloud.huawei.com/api/publish/v2/upload-url?appId=${HUAWEI_APP_ID}&suffix=apk" -H "Authorization: Bearer $ACCESS_TOKEN" -H "client_id: $HUAWEI_CLIENT_ID")
          UPLOAD_URL=$(echo "$UPLOAD_URL_RESPONSE" | jq -r '.uploadUrl')
          AUTH_CODE=$(echo "$UPLOAD_URL_RESPONSE" | jq -r '.authCode')

          APK_PATH="build/app/outputs/flutter-apk/app-release.apk"
          UPLOAD_RESULT=$(curl -s -k -X POST "$UPLOAD_URL" -F "file=@$APK_PATH" -F "authCode=$AUTH_CODE" -F "fileCount=1")
          FILE_DEST_URL=$(echo "$UPLOAD_RESULT" | jq -r '.result.UploadFileRsp.fileInfoList[0].fileDestUlr')

          UPDATE_BODY=$(jq -n --arg appId "$HUAWEI_APP_ID" --arg fileDestUrl "$FILE_DEST_URL" '{appId: $appId, fileType: 5, files: [{fileName: "app-release.apk", fileDestUrl: $fileDestUrl}]}')
          curl -s -X PUT "https://connect-api.cloud.huawei.com/api/publish/v2/app-file-info?appId=$HUAWEI_APP_ID" -H "Authorization: Bearer $ACCESS_TOKEN" -H "client_id: $HUAWEI_CLIENT_ID" -H "Content-Type: application/json" -d "$UPDATE_BODY"

          if [ "$SUBMIT" == "true" ]; then
             SUBMIT_BODY=$(jq -n --arg appId "$HUAWEI_APP_ID" '{appId: $appId}')
             curl -s -X POST "https://connect-api.cloud.huawei.com/api/publish/v2/app-submit?appId=$HUAWEI_APP_ID" -H "Authorization: Bearer $ACCESS_TOKEN" -H "client_id: $HUAWEI_CLIENT_ID" -H "Content-Type: application/json" -d "$SUBMIT_BODY"
          fi

  # ==============================================================================
  # 5. iOS APP STORE
  # ==============================================================================
  deploy-ios:
    name: üçé iOS App Store
    needs: bump-and-tag
    runs-on: macos-latest
    env:
      BUNDLE_ID: 'com.gavra013.gavra013ios'
      APP_ID: '6757114361'
      # VERSION_ID removed - determined dynamically
      APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      APP_STORE_CONNECT_KEY_IDENTIFIER: ${{ secrets.APP_STORE_CONNECT_KEY_IDENTIFIER }}
      APP_STORE_CONNECT_PRIVATE_KEY: ${{ secrets.APP_STORE_CONNECT_PRIVATE_KEY }}
      CERTIFICATE_PRIVATE_KEY: ${{ secrets.CERTIFICATE_PRIVATE_KEY }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref_name }}

      - name: Pull Latest Changes
        run: git pull origin ${{ github.ref_name }}

      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: 'stable'
          cache: true
      
      # USE CODEMAGIC TOOLS (Match ios-production.yml)
      - name: Install Codemagic CLI Tools
        run: pip install codemagic-cli-tools

      - name: Get dependencies
        run: flutter pub get

      - name: Setup keychain
        run: keychain initialize

      - name: Fetch signing files
        run: |
          app-store-connect fetch-signing-files "$BUNDLE_ID" \
            --type IOS_APP_STORE \
            --create

      - name: Setup certificates
        run: keychain add-certificates

      - name: Setup code signing
        run: xcode-project use-profiles

      - name: Create ExportOptions.plist
        run: |
          PROFILE_PATH=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision | head -n 1)
          echo "Found Profile Path: $PROFILE_PATH"
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< $(security cms -D -i "$PROFILE_PATH"))
          echo "Found Profile UUID: $PROFILE_UUID"

          if [ -z "$PROFILE_UUID" ]; then
            echo "Error: Could not extract UUID from profile"
            exit 1
          fi
          
          cat <<EOF > $HOME/export_options.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key>
            <string>app-store</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>$BUNDLE_ID</key>
              <string>$PROFILE_UUID</string>
            </dict>
          </dict>
          </plist>
          EOF

      - name: Install Pods
        run: |
          cd ios
          pod install

      - name: Build IPA
        run: |
          VERSION_NAME=$(echo "${{ needs.bump-and-tag.outputs.new_version }}" | cut -d+ -f1)
          # Ensure build number is integer (ios-production uses runs offset, here we use bumped version)
          VERSION_CODE=$(echo "${{ needs.bump-and-tag.outputs.new_version }}" | cut -d+ -f2)

          flutter build ipa --release \
            --build-name=$VERSION_NAME \
            --build-number=$VERSION_CODE \
            --export-options-plist=$HOME/export_options.plist

      - name: Upload to App Store Connect
        if: ${{ inputs.dry_run == false }}
        run: |
          app-store-connect publish --path build/ios/ipa/*.ipa
          echo "‚úÖ Build uploaded to App Store Connect!"

      - name: Wait for build processing
        if: ${{ inputs.dry_run == false }}
        run: |
          echo "‚è≥ Waiting 5 minutes for Apple to process build..."
          sleep 300
          echo "‚úÖ Build should be processed now"

      - name: Link and Submit (Optional)
        id: link_build
        if: ${{ inputs.dry_run == false && inputs.submit_for_review_ios == true }}
        shell: bash
        run: |
           # Use the version code we built with
           VERSION_STRING=$(echo "${{ needs.bump-and-tag.outputs.new_version }}" | cut -d+ -f1)
           BUILD_NUM=$(echo "${{ needs.bump-and-tag.outputs.new_version }}" | cut -d+ -f2)
           
           echo "üîç looking for BUILD_NUM: $BUILD_NUM and VERSION_STRING: $VERSION_STRING (App ID: $APP_ID)"

           python3 -c "
           import sys, json, subprocess, time
           
           def run_cmd(args):
               try:
                   print('Running: ' + ' '.join(args))
                   return subprocess.check_output(args, stderr=subprocess.STDOUT).decode('utf-8')
               except subprocess.CalledProcessError as e:
                   print('Command failed with output:\\n' + (e.output.decode("utf-8") if e.output else "No output"))
                   return None
           
           app_id = '$APP_ID'
           build_num = '$BUILD_NUM'
           version_string = '$VERSION_STRING'
           
           # 1. FIND THE BUILD ID
           print(f'--> 1. Finding Build ID for build number {build_num}...')
           build_id = None
           for i in range(3): # Retry loop
               out = run_cmd(['app-store-connect', 'builds', 'list', '--app-id', app_id, '--build-version-number', build_num, '--json'])
               if out:
                   try:
                       data = json.loads(out)
                       if data and len(data) > 0:
                           build_id = data[0]['id']
                           print(f'‚úÖ Found Build ID: {build_id}')
                           break
                   except:
                       pass
               print('... build not found yet, waiting 30s ...')
               time.sleep(30)
           
           if not build_id:
               print('‚ùå Could not find build ID after retries. Skipping submission.')
               sys.exit(0) # Exit success but skip
           
           # 2. FIND OR CREATE APP STORE VERSION
           print(f'--> 2. Finding App Store Version for {version_string}...')
           version_id = None
           
           # List versions
           out = run_cmd(['app-store-connect', 'app-store-versions', 'list', '--app-id', app_id, '--json'])
           if out:
               versions = json.loads(out)
               # Check for editable version
               for v in versions:
                   state = v.get('attributes', {}).get('appStoreState', '')
                   v_string = v.get('attributes', {}).get('versionString', '')
                   print(f'Found version: {v_string} (State: {state}) (ID: {v[\"id\"]})')
                   
                   if state in ['PREPARE_FOR_SUBMISSION', 'DEVELOPER_REJECTED', 'REJECTED']:
                       version_id = v['id']
                       print(f'‚úÖ Found editable version: {version_id}')
                       # Update version string if it doesn't match
                       if v_string != version_string:
                           print(f'Updating version string from {v_string} to {version_string}...')
                           run_cmd(['app-store-connect', 'app-store-versions', 'modify', '--id', version_id, '--version-string', version_string])
                       break
           
           if not version_id:
               print(f'No editable version found. Creating new version {version_string}...')
               try:
                   out = run_cmd(['app-store-connect', 'app-store-versions', 'create', 
                                  '--app-id', app_id, 
                                  '--version-string', version_string, 
                                  '--platform', 'IOS', 
                                  '--json'])
                   if out:
                        new_v = json.loads(out)
                        version_id = new_v['id']
                        print(f'‚úÖ Created new version: {version_id}')
               except Exception as e:
                   print(f'‚ö†Ô∏è Failed to create version: {e}')
                   sys.exit(1)
           
           if not version_id:
               print('‚ùå Could not determine Version ID. Exiting.')
               sys.exit(1)
           
           # 3. LINK BUILD TO VERSION
           print(f'--> 3. Linking Build {build_id} to Version {version_id}...')
           run_cmd(['app-store-connect', 'app-store-versions', 'modify', '--id', version_id, '--build-id', build_id])
           
           # 4. SUBMIT FOR REVIEW
           print(f'--> 4. Submitting Version {version_id} for Review...')
           run_cmd(['app-store-connect', 'app-store-version-submissions', 'create', '--app-store-version-id', version_id])
           "

