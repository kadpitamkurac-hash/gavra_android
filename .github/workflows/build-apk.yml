name: 'ðŸ“± Build APK'

on:
  workflow_dispatch:
    inputs:
      flutter_version:
        description: 'Flutter version to use'
        required: false
        default: '3.35.6'
        type: string

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'zulu'
        java-version: '21'

    - name: Setup Flutter
      uses: flutter-actions/setup-flutter@v3
      with:
        # Use the correct input key expected by the action
        version: ${{ inputs.flutter_version || '3.35.6' }}
        channel: 'stable'
        cache: true

    - name: Verify Flutter installation
      run: |
        flutter --version
        flutter doctor -v

    - name: Get Flutter dependencies
      run: |
        flutter pub get
        flutter pub deps

    - name: Clean build cache
      run: flutter clean

    - name: Disable Huawei plugin for CI
      run: |
        sed -i 's/classpath("com.huawei.agconnect:agcp:1.9.1.301")/\/\/ classpath("com.huawei.agconnect:agcp:1.9.1.301")/g' android/build.gradle.kts
        sed -i 's/agconnectServices { configFile file(".\/agconnect-services.json") }/\/\/ agconnectServices { configFile file(".\/agconnect-services.json") }/g' android/app/build.gradle.kts
        # Also comment-out the plugin id to avoid applying the Huawei AGC Gradle plugin in CI
        sed -i 's/id("com.huawei.agconnect")/\/\/ id("com.huawei.agconnect")/g' android/app/build.gradle.kts
        # Verify changes (print matching lines) so CI logs show whether AGC references remain
        echo "---- android/build.gradle.kts matches ----"
        grep -n 'agconnect\|com.huawei.agconnect' android/build.gradle.kts || true
        echo "---- android/app/build.gradle.kts matches ----"
        grep -n 'agconnect\|com.huawei.agconnect' android/app/build.gradle.kts || true

    - name: Restore keystore from secrets (CI only)
      run: |
        # Support existing secret name KEYSTORE_BASE64 as used by the "Quick APK Build" workflow
        KEYSTORE_B64="${{ secrets.ANDROID_KEYSTORE_BASE64 }}"
        if [ -z "$KEYSTORE_B64" ]; then
          KEYSTORE_B64="${{ secrets.KEYSTORE_BASE64 }}"
        fi
        if [ -z "$KEYSTORE_B64" ]; then
          echo "No keystore secret found (checked ANDROID_KEYSTORE_BASE64 and KEYSTORE_BASE64) â€” skipping keystore restore"
          exit 0
        fi
        echo "Restoring keystore to android/app/key.jks"
        mkdir -p android/app
        echo "$KEYSTORE_B64" | base64 --decode > android/app/key.jks
        ls -la android/app/key.jks

    - name: Create key.properties from secrets (CI only)
      run: |
        # Support legacy secret names used in other workflows
        STORE_PASS="${{ secrets.ANDROID_KEYSTORE_PASSWORD }}"
        if [ -z "$STORE_PASS" ]; then
          STORE_PASS="${{ secrets.KEYSTORE_PASSWORD }}"
          if [ -z "$STORE_PASS" ]; then
            STORE_PASS="${{ secrets.STORE_PASSWORD }}"
          fi
        fi

        KEY_PASS="${{ secrets.ANDROID_KEY_PASSWORD }}"
        if [ -z "$KEY_PASS" ]; then
          KEY_PASS="${{ secrets.KEY_PASSWORD }}"
        fi

        KEY_ALIAS_VAL="${{ secrets.ANDROID_KEY_ALIAS }}"
        if [ -z "$KEY_ALIAS_VAL" ]; then
          KEY_ALIAS_VAL="${{ secrets.KEY_ALIAS }}"
        fi

        if [ -z "$STORE_PASS" ] || [ -z "$KEY_ALIAS_VAL" ] || [ -z "$KEY_PASS" ]; then
          echo "Key properties secrets not fully set â€” skipping key.properties creation"
          exit 0
        fi

        cat > key.properties <<EOF
storePassword=$STORE_PASS
keyPassword=$KEY_PASS
keyAlias=$KEY_ALIAS_VAL
storeFile=android/app/key.jks
EOF
        echo "Created key.properties (storeFile=android/app/key.jks)"
        ls -la key.properties || true

    - name: Verify keystore presence (CI)
      run: |
        echo "Verifying keystore and key.properties..."
        if [ -f key.properties ]; then
          STORE=$(grep '^storeFile=' key.properties | cut -d= -f2 | tr -d '\r' | xargs)
          if [ -z "$STORE" ] || [ ! -f "$STORE" ]; then
            echo "::warning::Keystore file referenced in key.properties not found: $STORE"
            echo "The build will continue unsigned. If you want a signed APK, ensure keystore secrets are set."
          else
            echo "Keystore found: $STORE"
          fi
        else
          echo "::warning::key.properties not found. Build will continue unsigned."
        fi

    - name: Build APK
      env:
        # Expose keystore envs (used by other workflows and convenient for debugging)
        KEYSTORE_PATH: android/app/key.jks
        KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD || secrets.ANDROID_KEYSTORE_PASSWORD || secrets.STORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.KEY_ALIAS || secrets.ANDROID_KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.KEY_PASSWORD || secrets.ANDROID_KEY_PASSWORD }}
      run: |
        # Use split-per-abi to produce per-ABI APKs (consistent with Quick APK workflow)
        flutter build apk --release --dart-define=FLAVOR=production --split-per-abi

    - name: Collect APKs and Rename with version
      run: |
        VERSION=$(grep "version:" pubspec.yaml | head -1 | cut -d: -f2 | xargs)
        BUILD_NUM=${{ github.run_number }}
        mkdir -p release_apk
        # Copy all APKs produced by split-per-abi
        cp build/app/outputs/flutter-apk/*.apk release_apk/ || true
        # Rename them to include version/build in filename
        for f in release_apk/*.apk; do
          base=$(basename "$f")
          mv "$f" "release_apk/gavra-${base%-*.apk}-v${VERSION}-build${BUILD_NUM}.apk"
        done
        ls -la release_apk

    - name: Upload APK artifact
      uses: actions/upload-artifact@v4
      with:
        name: gavra-apk
        path: release_apk/*.apk
        retention-days: 30

    - name: Display APK info
      run: |
        echo "APK built successfully!"
        echo "File: ${{ env.APK_NAME }}"
        ls -la release_apk/